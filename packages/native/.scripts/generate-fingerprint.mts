import * as crypto from 'node:crypto';
import * as fs from 'node:fs/promises';
import * as path from 'node:path';
import * as esbuild from 'esbuild';

const ROOT = path.resolve(import.meta.dirname, '../');
const AUTO_GENERATED_COMMENT = '// This file is auto-generated by the generate-fingerprint script.';

const CJS_TEMPLATE = `
${AUTO_GENERATED_COMMENT}
module.exports = '$FINGERPRINT';
`.trim();

const ESM_TEMPLATE = `
${AUTO_GENERATED_COMMENT}
export default '$FINGERPRINT';
`.trim();

const resolvedPackages: Record<string, string> = {};
const nativePackages = JSON.parse(await fs.readFile(path.join(ROOT, 'native-packages.json'), 'utf-8')) as string[];

try {
  await esbuild.build({
    bundle: true,
    treeShaking: false,
    logLevel: 'silent',
    format: 'esm',
    stdin: {
      contents: `${nativePackages.map((pkg) => `import '${pkg}';`).join('\n')}`,
    },
    plugins: [
      {
        name: 'resolve-strict-package-version',
        setup(build) {
          const RESOLVING = Symbol();

          build.onResolve({ filter: /.*/ }, async (args) => {
            if (args.pluginData === RESOLVING) {
              return;
            }

            const resolveOptions = {
              importer: args.importer,
              kind: args.kind,
              resolveDir: ROOT,
              pluginData: RESOLVING,
            };

            // 1. Try to resolve '{packageName}/package.json'
            let result = await build.resolve(path.join(args.path, 'package.json'), resolveOptions);

            // 2. If not found, try to resolve '{packageName}'
            if (result.errors.length) {
              result = await build.resolve(args.path, resolveOptions);
            }

            if (result.errors.length) {
              return result;
            }

            const packageName = args.path;
            const packagePath = extractPackagePath(result.path, packageName);

            if (packagePath) {
              resolvedPackages[packageName] = await getPackageVersion(packagePath);
            }

            return result;
          });
        },
      },
    ],
  });
} catch (error) {
  console.error('Failed to resolve package versions:', error);
  process.exit(1);
}

function extractPackagePath(path: string, packageName: string) {
  const normalizedPath = path.replace(/\\/g, '/');

  if (normalizedPath.endsWith('/package.json')) {
    return normalizedPath.replace(/\/package\.json$/, '');
  }

  const match = normalizedPath.match(new RegExp(`(.*?node_modules/${packageName})/.*$`));

  if (match) {
    return match[1]!;
  }

  throw new Error(`Failed to extract path: ${packageName}`);
}

async function getPackageVersion(packagePath: string) {
  const packageJson = JSON.parse(await fs.readFile(path.join(packagePath, 'package.json'), 'utf-8'));

  return packageJson.version;
}

const depsString = Object.entries(resolvedPackages)
  .map(([pkg, version]) => `${pkg}@${version}`)
  .join(' ');
const fingerprint = crypto.createHash('md5').update(depsString).digest('hex');

const cjsString = CJS_TEMPLATE.replace('$FINGERPRINT', fingerprint);
const esmString = ESM_TEMPLATE.replace('$FINGERPRINT', fingerprint);

console.log(`ðŸ‘‰ Generated fingerprint: ${fingerprint}`);

await fs.writeFile(path.join(ROOT, 'fingerprint/index.js'), cjsString, 'utf-8');
await fs.writeFile(path.join(ROOT, 'fingerprint/index.mjs'), esmString, 'utf-8');

console.log('âœ… Done!');

process.exit(0);
