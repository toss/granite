import * as crypto from 'node:crypto';
import * as fs from 'node:fs/promises';
import * as path from 'node:path';
import * as esbuild from 'esbuild';

const ROOT = path.resolve(import.meta.dirname, '../');
const AUTO_GENERATED_COMMENT = '// This file is auto-generated by the generate-fingerprint script.';

const CJS_TEMPLATE = `
${AUTO_GENERATED_COMMENT}
module.exports = '$FINGERPRINT';
`.trim();

const ESM_TEMPLATE = `
${AUTO_GENERATED_COMMENT}
export default '$FINGERPRINT';
`.trim();

const resolvedPackages: Record<string, string> = {};
const nativePackages = JSON.parse(await fs.readFile(path.join(ROOT, 'native-packages.json'), 'utf-8')) as string[];

await esbuild.build({
  bundle: true,
  treeShaking: false,
  logLevel: 'silent',
  format: 'esm',
  stdin: {
    contents: `${nativePackages.map((pkg) => `import '${pkg}';`).join('\n')}`,
  },
  plugins: [
    {
      name: 'resolve-strict-package-version',
      setup(build) {
        const RESOLVING = Symbol();

        build.onResolve({ filter: /.*/ }, async (args) => {
          if (args.pluginData === RESOLVING) {
            return;
          }

          const resolveOptions = {
            importer: args.importer,
            kind: args.kind,
            resolveDir: ROOT,
            pluginData: RESOLVING,
          };

          // 1. Try to resolve '{packageName}/package.json'
          let result = await build.resolve(path.join(args.path, 'package.json'), resolveOptions);

          // 2. If not found, try to resolve '{packageName}'
          if (result.errors.length) {
            result = await build.resolve(args.path, resolveOptions);
          }

          if (result.errors.length) {
            return result;
          }

          const packageName = args.path;
          const packagePath = extractPackagePath(result.path, packageName);

          if (packagePath) {
            resolvedPackages[packageName] = await getPackageVersion(packagePath);
          }

          return result;
        });
      },
    },
  ],
});

function extractPackagePath(path: string, packageName: string) {
  const normalizedPath = path.replace(/\\/g, '/');

  if (normalizedPath.endsWith('/package.json')) {
    return normalizedPath.replace(/\/package\.json$/, '');
  }

  const match = normalizedPath.match(new RegExp(`(.*?node_modules/${packageName})/.*$`));

  if (match) {
    return match[1]!;
  }

  throw new Error(`Failed to extract path: ${packageName}`);
}

async function getPackageVersion(packagePath: string) {
  const packageJson = JSON.parse(await fs.readFile(path.join(packagePath, 'package.json'), 'utf-8'));

  return packageJson.version;
}

const depsString = Object.entries(resolvedPackages)
  .map(([pkg, version]) => `${pkg}@${version}`)
  .join(' ');
const fingerprint = crypto.createHash('md5').update(depsString).digest('hex');

const cjsString = CJS_TEMPLATE.replace('$FINGERPRINT', fingerprint);
const esmString = ESM_TEMPLATE.replace('$FINGERPRINT', fingerprint);

console.log(`ðŸ‘‰ Generated fingerprint: ${fingerprint}`);

await fs.writeFile(path.join(ROOT, 'fingerprint/index.js'), cjsString, 'utf-8');
await fs.writeFile(path.join(ROOT, 'fingerprint/index.mjs'), esmString, 'utf-8');

console.log('âœ… Done!');

process.exit(0);
