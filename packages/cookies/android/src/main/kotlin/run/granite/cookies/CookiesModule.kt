/**
 * Cookies module implementation for Android Implements the CookiesSpec interface generated by
 * brick-codegen
 *
 * Uses Android's CookieManager for cookie management
 */
package run.granite.cookies

import android.os.Build
import android.webkit.CookieManager
import android.webkit.CookieSyncManager
import android.webkit.ValueCallback
import com.brickmodule.*
import com.facebook.react.bridge.ReactContext
import com.facebook.react.bridge.WritableMap
import com.facebook.react.bridge.WritableNativeMap
import java.net.URI
import java.util.*
import kotlin.coroutines.resume
import kotlinx.coroutines.suspendCancellableCoroutine

class CookiesModule(reactContext: ReactContext) : BrickModuleSpec(reactContext), CookiesSpec {

    override val moduleName: String = "Cookies"

    private val cookieManager: CookieManager by lazy {
        CookieManager.getInstance().apply { setAcceptCookie(true) }
    }

    // MARK: - Set Cookie

    override suspend fun set(url: String, cookie: Cookie, useWebKit: Boolean): Boolean {
        val cookieString = buildCookieString(cookie)

        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            suspendCancellableCoroutine { continuation ->
                cookieManager.setCookie(
                        url,
                        cookieString,
                        ValueCallback { success -> continuation.resume(success ?: false) }
                )
            }
        } else {
            @Suppress("DEPRECATION") cookieManager.setCookie(url, cookieString)
            syncCookiesLegacy()
            true
        }
    }

    // MARK: - Get Cookies

    override suspend fun get(url: String, useWebKit: Boolean): WritableMap {
        val cookieString = cookieManager.getCookie(url) ?: return WritableNativeMap()
        return parseCookieString(cookieString, url)
    }

    // MARK: - Get All Cookies

    override suspend fun getAll(useWebKit: Boolean): WritableMap {
        // Android's CookieManager doesn't provide a way to get all cookies
        // This is a platform limitation - return empty map
        return WritableNativeMap()
    }

    // MARK: - Clear All Cookies

    override suspend fun clearAll(useWebKit: Boolean): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            suspendCancellableCoroutine { continuation ->
                cookieManager.removeAllCookies(
                        ValueCallback { success -> continuation.resume(success ?: false) }
                )
            }
        } else {
            @Suppress("DEPRECATION") cookieManager.removeAllCookie()
            syncCookiesLegacy()
            true
        }
    }

    // MARK: - Clear By Name

    override suspend fun clearByName(url: String, name: String, useWebKit: Boolean): Boolean {
        // Android doesn't provide a direct way to delete individual cookies
        // We need to set an expired cookie with the same name
        val expiredCookie =
                Cookie(
                        name = name,
                        value = "",
                        path = "/",
                        domain = null,
                        version = null,
                        expires = "Thu, 01 Jan 1970 00:00:00 GMT",
                        secure = null,
                        httpOnly = null
                )

        return set(url, expiredCookie, useWebKit)
    }

    // MARK: - Set From Response

    override suspend fun setFromResponse(url: String, cookie: String): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            suspendCancellableCoroutine { continuation ->
                cookieManager.setCookie(
                        url,
                        cookie,
                        ValueCallback { success -> continuation.resume(success ?: false) }
                )
            }
        } else {
            @Suppress("DEPRECATION") cookieManager.setCookie(url, cookie)
            syncCookiesLegacy()
            true
        }
    }

    // MARK: - Get From Response

    override suspend fun getFromResponse(url: String): WritableMap {
        return get(url, false)
    }

    // MARK: - Flush

    override suspend fun flush(): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            cookieManager.flush()
            true
        } else {
            syncCookiesLegacy()
            true
        }
    }

    // MARK: - Remove Session Cookies

    override suspend fun removeSessionCookies(): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
            suspendCancellableCoroutine { continuation ->
                cookieManager.removeSessionCookies(
                        ValueCallback { success -> continuation.resume(success ?: false) }
                )
            }
        } else {
            @Suppress("DEPRECATION") cookieManager.removeSessionCookie()
            syncCookiesLegacy()
            true
        }
    }

    // MARK: - Helper Methods

    private fun buildCookieString(cookie: Cookie): String {
        val builder = StringBuilder()
        builder.append("${cookie.name}=${cookie.value}")

        cookie.path?.let { builder.append("; path=$it") }
        cookie.domain?.let { builder.append("; domain=$it") }
        cookie.expires?.let { builder.append("; expires=$it") }
        cookie.secure?.let { if (it) builder.append("; secure") }

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
            cookie.httpOnly?.let { if (it) builder.append("; httponly") }
        }

        return builder.toString()
    }

    private fun parseCookieString(cookieString: String, url: String): WritableMap {
        val result = WritableNativeMap()

        // Cookie string format: "name1=value1; name2=value2"
        val pairs = cookieString.split(";").map { it.trim() }

        for (pair in pairs) {
            if (pair.isEmpty()) continue

            val equalIndex = pair.indexOf('=')
            if (equalIndex <= 0) continue

            val name = pair.substring(0, equalIndex).trim()
            val value = pair.substring(equalIndex + 1).trim()

            // Skip cookie attributes (they start with known prefixes)
            if (name.lowercase() in
                            listOf(
                                    "path",
                                    "domain",
                                    "expires",
                                    "max-age",
                                    "secure",
                                    "httponly",
                                    "samesite"
                            )
            ) {
                continue
            }

            val domain =
                    try {
                        URI(url).host
                    } catch (e: Exception) {
                        null
                    }

            val cookieMap =
                    WritableNativeMap().apply {
                        putString("name", name)
                        putString("value", value)
                        putString("path", "/")
                        domain?.let { putString("domain", it) }
                    }

            result.putMap(name, cookieMap)
        }

        return result
    }

    @Suppress("DEPRECATION")
    private fun syncCookiesLegacy() {
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.LOLLIPOP) {
            CookieSyncManager.getInstance().sync()
        }
    }
}
