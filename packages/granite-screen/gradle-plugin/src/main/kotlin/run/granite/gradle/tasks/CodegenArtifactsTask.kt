package run.granite.gradle.tasks

import org.gradle.api.DefaultTask
import org.gradle.api.file.DirectoryProperty
import org.gradle.api.file.RegularFileProperty
import org.gradle.api.provider.Property
import org.gradle.api.tasks.*
import org.gradle.process.ExecOperations
import run.granite.gradle.utils.NodeExecutableFinder
import java.io.ByteArrayOutputStream
import java.io.File
import javax.inject.Inject

/**
 * Gradle task for React Native Codegen artifact generation.
 *
 * This task:
 * 1. Reads the schema.json generated by CodegenSchemaTask
 * 2. Executes React Native codegen to generate native code
 * 3. Outputs Java/Kotlin and C++ source files for TurboModules and Fabric components
 *
 * Generated artifacts include:
 * - Java/Kotlin interfaces for TurboModules
 * - JNI C++ bindings
 * - Fabric component descriptors
 *
 * Inputs:
 * - schema.json file
 * - React Native directory (for codegen binary)
 * - Package name for generated Java code
 *
 * Outputs:
 * - Java sources in build/generated/codegen/java/
 * - C++ sources in build/generated/codegen/jni/
 */
@CacheableTask
abstract class CodegenArtifactsTask @Inject constructor(
  private val execOperations: ExecOperations,
) : DefaultTask() {

  /**
   * Schema file generated by CodegenSchemaTask.
   */
  @get:InputFile
  @get:PathSensitive(PathSensitivity.RELATIVE)
  abstract val schemaFile: RegularFileProperty

  /**
   * React Native directory containing codegen tools.
   * Marked as Internal to avoid task output overlaps with other modules.
   */
  @get:Internal
  abstract val reactNativeDir: DirectoryProperty

  /**
   * Node modules directory.
   * Marked as Internal to avoid task output overlaps with other modules.
   */
  @get:Internal
  abstract val nodeModulesDir: DirectoryProperty

  /**
   * Package name for generated Java code.
   */
  @get:Input
  abstract val packageName: Property<String>

  /**
   * Library name for generated code.
   */
  @get:Input
  abstract val libraryName: Property<String>

  /**
   * Output directory for generated Java sources.
   */
  @get:OutputDirectory
  abstract val javaOutputDir: DirectoryProperty

  /**
   * Output directory for generated C++ JNI sources.
   */
  @get:OutputDirectory
  abstract val jniOutputDir: DirectoryProperty

  init {
    group = "granite"
    description = "Generates React Native Codegen artifacts (Java and C++)"
  }

  @TaskAction
  fun execute() {
    logger.lifecycle("Generating React Native Codegen artifacts...")

    val schemaFileResolved = schemaFile.get().asFile

    if (!schemaFileResolved.exists()) {
      error(
        """
                |Schema file not found: ${schemaFileResolved.absolutePath}
                |
                |The schema should be generated by CodegenSchemaTask.
                |Ensure CodegenSchemaTask runs before CodegenArtifactsTask.
        """.trimMargin(),
      )
    }

    // Execute codegen binary
    executeCodegen()

    logger.lifecycle("Codegen artifacts generated successfully")
  }

  /**
   * Executes the React Native codegen binary.
   *
   * Implementation details in corresponding task.
   */
  private fun executeCodegen() {
    val codegenBinary = findCodegenBinary()
    val nodeExecutable = NodeExecutableFinder.findNodeExecutable()

    if (!codegenBinary.exists()) {
      logger.warn(
        """
                |React Native codegen binary not found: ${codegenBinary.absolutePath}
                |
                |Skipping codegen generation. This is expected if your library has no TurboModules or Fabric components.
        """.trimMargin(),
      )
      // Create empty output directories
      javaOutputDir.get().asFile.mkdirs()
      jniOutputDir.get().asFile.mkdirs()
      return
    }

    // Prepare output directories
    val javaOutputDirFile = javaOutputDir.get().asFile
    val jniOutputDirFile = jniOutputDir.get().asFile

    javaOutputDirFile.mkdirs()
    jniOutputDirFile.mkdirs()

    // Execute codegen
    // Command: node path/to/codegen/lib/cli/combine/combine-js-to-schema-cli.js schema-file output-dir
    val command = listOf(
      nodeExecutable.absolutePath,
      codegenBinary.absolutePath,
      "--schema", schemaFile.get().asFile.absolutePath,
      "--javaPackageName", packageName.get(),
      "--libraryName", libraryName.get(),
      "--outputDir", javaOutputDirFile.absolutePath,
      "--jniOutputDir", jniOutputDirFile.absolutePath,
    )

    logger.debug("Executing codegen: ${command.joinToString(" ")}")

    val stdout = ByteArrayOutputStream()
    val stderr = ByteArrayOutputStream()

    val result = execOperations.exec {
      commandLine = command
      standardOutput = stdout
      errorOutput = stderr
      isIgnoreExitValue = true
    }

    if (result.exitValue != 0) {
      logger.warn(
        """
                |Codegen execution completed with warnings (exit code: ${result.exitValue})
                |
                |This is expected if your library has no TurboModules or Fabric components.
                |
                |Error output:
                |$stderr
        """.trimMargin(),
      )
    } else {
      logger.debug("Codegen output: $stdout")
    }

    // Verify output was generated
    if (javaOutputDirFile.listFiles()?.isEmpty() != false &&
      jniOutputDirFile.listFiles()?.isEmpty() != false
    ) {
      logger.lifecycle("No codegen artifacts generated (no TurboModules/Fabric components found)")
    } else {
      logger.lifecycle("Generated Java sources: ${javaOutputDirFile.absolutePath}")
      logger.lifecycle("Generated C++ sources: ${jniOutputDirFile.absolutePath}")
    }
  }

  /**
   * Finds the React Native codegen binary.
   */
  private fun findCodegenBinary(): File {
    // Try multiple possible locations
    val possiblePaths = listOf(
      "react-native-codegen/lib/cli/combine/combine-js-to-schema-cli.js",
      "@react-native/codegen/lib/cli/combine/combine-js-to-schema-cli.js",
      "react-native/node_modules/@react-native/codegen/lib/cli/combine/combine-js-to-schema-cli.js",
    )

    val nodeModules = nodeModulesDir.get().asFile

    for (path in possiblePaths) {
      val codegenFile = nodeModules.resolve(path)
      if (codegenFile.exists()) {
        logger.debug("Found codegen binary: ${codegenFile.absolutePath}")
        return codegenFile
      }
    }

    // Return a placeholder file (will be checked for existence later)
    return nodeModules.resolve(possiblePaths.first())
  }
}
