package run.granite.gradle.generators

import run.granite.gradle.models.NativeModule
import java.io.File

/**
 * Generates autolinking.cpp with concrete implementations of autolinking functions.
 *
 * This generator creates C++ code that:
 * - Implements autolinking_ModuleProvider for Java TurboModules
 * - Implements autolinking_cxxModuleProvider for C++ TurboModules
 * - Includes proper headers for C++ TurboModules
 * - Returns nullptr when no match is found (early-return pattern)
 * - Sanitizes C++ identifiers
 */
object CppAutolinkingGenerator {
  /**
   * Generates autolinking.cpp file content.
   *
   * @param modules List of all native modules
   * @return Generated C++ code as string
   */
  fun generate(modules: List<NativeModule>): String {
    val cxxModules = modules.filter { it.hasCxxImplementation }
    val javaModules = modules.filter { it.hasJavaImplementation }
    val fabricLibraries =
      modules
        .filter { it.hasFabricComponents }
        .mapNotNull { module ->
          val libraryName = module.libraryName ?: return@mapNotNull null
          libraryName to module.componentDescriptors
        }
        .groupBy({ it.first }, { it.second })
        .mapValues { (_, descriptorLists) -> descriptorLists.flatten().distinct() }
        .toSortedMap()

    return buildString {
      appendLine("// Generated by Granite Gradle Plugin - DO NOT EDIT")
      appendLine("// This file is automatically generated during the build process")
      appendLine()
      appendLine("#include <autolinking.h>")
      appendLine()

      // C++ TurboModule headers
      if (cxxModules.isNotEmpty()) {
        appendLine("// C++ TurboModule headers")
        cxxModules.forEach { module ->
          module.cxxModuleHeaderName?.let { headerName ->
            appendLine("#include <$headerName.h>")
          }
        }
        appendLine()
      }

      // Fabric component descriptor headers
      if (fabricLibraries.isNotEmpty()) {
        appendLine("// Fabric component descriptor headers")
        fabricLibraries.forEach { (libraryName, componentDescriptors) ->
          appendLine("#if defined(__has_include) && __has_include(<react/renderer/components/$libraryName/ComponentDescriptors.h>)")
          appendLine("#include <react/renderer/components/$libraryName/ComponentDescriptors.h>")
          appendLine("#endif")
          componentDescriptors.forEach { descriptor ->
            appendLine("#if defined(__has_include) && __has_include(<react/renderer/components/$libraryName/$descriptor.h>)")
            appendLine("#include <react/renderer/components/$libraryName/$descriptor.h>")
            appendLine("#endif")
          }
        }
        appendLine()
      }

      appendLine("namespace facebook::react {")
      appendLine()

      // autolinking_registerProviders function
      appendLine("void autolinking_registerProviders(")
      appendLine("    std::shared_ptr<const ComponentDescriptorProviderRegistry> registry) {")
      if (fabricLibraries.isNotEmpty()) {
        appendLine("  // Register Fabric component descriptors from autolinked libraries")
        fabricLibraries.forEach { (libraryName, componentDescriptors) ->
          appendLine("#if defined(__has_include) && __has_include(<react/renderer/components/$libraryName/ComponentDescriptors.h>)")
          appendLine("  ${libraryName}_registerComponentDescriptorsFromCodegen(registry);")
          appendLine("#endif")
          componentDescriptors.forEach { descriptor ->
            appendLine("#if defined(__has_include) && __has_include(<react/renderer/components/$libraryName/$descriptor.h>)")
            appendLine("  registry->add(concreteComponentDescriptorProvider<$descriptor>());")
            appendLine("#endif")
          }
        }
      } else {
        appendLine("  // No autolinked Fabric components found")
      }
      appendLine("}")
      appendLine()

      // autolinking_cxxModuleProvider function
      appendLine("std::shared_ptr<TurboModule> autolinking_cxxModuleProvider(")
      appendLine("    const std::string& moduleName,")
      appendLine("    const std::shared_ptr<CallInvoker>& jsInvoker) {")
      if (cxxModules.isNotEmpty()) {
        appendLine("  // Check C++ TurboModules (early-return pattern)")
        cxxModules.forEach { module ->
          module.cxxModuleHeaderName?.let { headerName ->
            appendLine("  if (moduleName == $headerName::kModuleName) {")
            appendLine("    return std::make_shared<$headerName>(jsInvoker);")
            appendLine("  }")
          }
        }
      } else {
        appendLine("  // No autolinked C++ TurboModules found")
      }
      appendLine()
      appendLine("  return nullptr;")
      appendLine("}")
      appendLine()

      // autolinking_ModuleProvider function
      appendLine("std::shared_ptr<TurboModule> autolinking_ModuleProvider(")
      appendLine("    const std::string& moduleName,")
      appendLine("    const JavaTurboModule::InitParams& params) {")
      if (javaModules.isNotEmpty()) {
        appendLine("  // Delegate to Java TurboModule providers (early-return pattern)")
        javaModules.forEach { module ->
          module.libraryName?.let { libraryName ->
            val sanitized = module.sanitizedName()
            appendLine("  auto module_$sanitized = ${libraryName}_ModuleProvider(moduleName, params);")
            appendLine("  if (module_$sanitized != nullptr) {")
            appendLine("    return module_$sanitized;")
            appendLine("  }")
          }
        }
      } else {
        appendLine("  // No autolinked Java TurboModules found")
      }
      appendLine()
      appendLine("  return nullptr;")
      appendLine("}")
      appendLine()

      appendLine("} // namespace facebook::react")
    }
  }

  /**
   * Writes autolinking.cpp to the specified output directory.
   */
  fun generateToFile(modules: List<NativeModule>, outputDir: File) {
    val content = generate(modules)
    val outputFile = File(outputDir, "autolinking.cpp")
    outputFile.parentFile.mkdirs()
    outputFile.writeText(content)
  }
}
