package run.granite.gradle.generators

import run.granite.gradle.models.NativeModule
import java.io.File
import java.util.logging.Logger

/**
 * Generates Android-autolinking.cmake configuration file for React Native native modules.
 *
 * This generator creates a CMake configuration file that:
 * - Adds subdirectories for each native module
 * - Sets REACTNATIVE_MERGED_SO=true for React Native 0.76+
 * - Sanitizes paths (escape spaces, remove CMakeLists.txt)
 * - Creates unique build directory names ({libraryName}_autolinked_build)
 * - Handles both standard and cxxModule CMakeLists.txt
 * - Generates AUTOLINKED_LIBRARIES list with react_codegen_* prefixes
 */
object CMakeGenerator {
  private val logger = Logger.getLogger(CMakeGenerator::class.java.name)

  /**
   * Generates Android-autolinking.cmake file content.
   *
   * @param modules List of all native modules
   * @param projectRoot Root directory of the project for path resolution
   * @return Generated CMake code as string
   */
  fun generate(modules: List<NativeModule>, projectRoot: File): String {
    // Filter out brick-module as it uses a special codegen pattern
    val cmakeModules = modules.filter { it.hasCMakeConfiguration }

    if (cmakeModules.isEmpty()) {
      // Skip CMake generation if no modules with native code
      return generateEmptyFile()
    }

    // Collect all CMake entries from modules
    val allEntries = cmakeModules.flatMap { it.cmakeEntries() }

    // Filter entries to only include directories that actually exist
    val existingEntries = allEntries.filter { entry ->
      val sanitizedPath = entry.sanitizedPath(projectRoot)
      File(sanitizedPath).exists().also { exists ->
        if (!exists) {
          logger.warning("Skipping non-existent CMake directory: $sanitizedPath")
        }
      }
    }

    val allLibraryTargets = existingEntries.flatMap { it.libraryTargets }

    return buildString {
      appendLine("# Generated by Granite Gradle Plugin - DO NOT EDIT")
      appendLine("# This file is automatically generated during the build process")
      appendLine()

      // Set REACTNATIVE_MERGED_SO=true for React Native 0.76+
      appendLine("# Enable merged shared object model for React Native 0.76+")
      appendLine("set(REACTNATIVE_MERGED_SO true)")
      appendLine()

      if (existingEntries.isNotEmpty()) {
        appendLine("# Add native module directories")
        existingEntries.forEach { entry ->
          appendLine(entry.toCMakeCommand(projectRoot))
        }
        appendLine()
      }

      // Initialize empty AUTOLINKED_LIBRARIES and conditionally append targets
      // This ensures clean works even when codegen directories don't exist
      appendLine("# Autolinked library targets (conditionally added based on existence)")
      appendLine("set(AUTOLINKED_LIBRARIES \"\")")
      existingEntries.forEach { entry ->
        entry.libraryTargets.forEach { target ->
          appendLine("if(TARGET $target)")
          appendLine("  list(APPEND AUTOLINKED_LIBRARIES $target)")
          appendLine("endif()")
        }
      }
    }
  }

  /**
   * Generates an empty CMake file with explanatory comment.
   */
  private fun generateEmptyFile(): String = buildString {
    appendLine("# Generated by Granite Gradle Plugin - DO NOT EDIT")
    appendLine("# This file is automatically generated during the build process")
    appendLine()
    appendLine("# No native modules with CMake configuration found")
    appendLine("set(REACTNATIVE_MERGED_SO true)")
    appendLine("set(AUTOLINKED_LIBRARIES)")
  }

  /**
   * Writes Android-autolinking.cmake to the specified output directory.
   */
  fun generateToFile(modules: List<NativeModule>, projectRoot: File, outputDir: File) {
    val content = generate(modules, projectRoot)
    val outputFile = File(outputDir, "Android-autolinking.cmake")
    outputFile.parentFile.mkdirs()
    outputFile.writeText(content)
  }
}
