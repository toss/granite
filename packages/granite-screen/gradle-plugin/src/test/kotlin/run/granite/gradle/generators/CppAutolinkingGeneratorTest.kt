package run.granite.gradle.generators

import run.granite.gradle.fixtures.NativeModuleFixtures
import run.granite.gradle.models.NativeModule
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Test

/**
 * Unit tests for CppAutolinkingGenerator core generation logic.
 * Tests C++ code generation with various module configurations.
 */
class CppAutolinkingGeneratorTest {

    @Test
    fun `generate with no modules creates empty implementations`() {
        val modules = emptyList<NativeModule>()

        val generated = CppAutolinkingGenerator.generate(modules)

        // Should contain auto-generated comment
        assertThat(generated).contains("Generated by Granite Gradle Plugin - DO NOT EDIT")

        // Should include autolinking.h
        assertThat(generated).contains("#include <autolinking.h>")

        // Should have namespace
        assertThat(generated).contains("namespace facebook::react {")

        // Should have registerProviders with "no Fabric components" comment
        assertThat(generated).contains("void autolinking_registerProviders(")
        assertThat(generated).contains("// No autolinked Fabric components found")

        // Should have cxxModuleProvider returning nullptr
        assertThat(generated).contains("std::shared_ptr<TurboModule> autolinking_cxxModuleProvider(")
        assertThat(generated).contains("// No autolinked C++ TurboModules found")
        assertThat(generated).contains("return nullptr;")

        // Should have ModuleProvider returning nullptr
        assertThat(generated).contains("std::shared_ptr<TurboModule> autolinking_ModuleProvider(")
        assertThat(generated).contains("// No autolinked Java TurboModules found")
    }

    @Test
    fun `generate with Java-only module includes module provider call`() {
        val modules = listOf(
            NativeModule(
                name = "react-native-webview",
                packageImportPath = "com.example.Package",
                packageInstance = "new Package()",
                dependencyConfiguration = null,
                buildTypes = emptyList(),
                libraryName = "RNCWebView",
                componentDescriptors = emptyList(),
                cmakeListsPath = null,
                cxxModuleCMakeListsPath = null,
                cxxModuleCMakeListsModuleName = null,
                cxxModuleHeaderName = null,
                isPureCxxDependency = false
            )
        )

        val generated = CppAutolinkingGenerator.generate(modules)

        // Should have Java module provider call
        assertThat(generated).contains("auto module_react_native_webview = RNCWebView_ModuleProvider(moduleName, params);")
        assertThat(generated).contains("if (module_react_native_webview != nullptr) {")
        assertThat(generated).contains("return module_react_native_webview;")

        // Should not have C++ module headers or checks
        assertThat(generated).doesNotContain("// C++ TurboModule headers")
        assertThat(generated).contains("// No autolinked C++ TurboModules found")

        // Should have "no Fabric components" comment
        assertThat(generated).contains("// No autolinked Fabric components found")
    }

    @Test
    fun `generate with C++ module includes header and provider check`() {
        val modules = listOf(
            NativeModule(
                name = "cxx-module",
                packageImportPath = null,
                packageInstance = null,
                dependencyConfiguration = null,
                buildTypes = emptyList(),
                libraryName = "CxxModule",
                componentDescriptors = emptyList(),
                cmakeListsPath = null,
                cxxModuleCMakeListsPath = null,
                cxxModuleCMakeListsModuleName = null,
                cxxModuleHeaderName = "CxxModule",
                isPureCxxDependency = true
            )
        )

        val generated = CppAutolinkingGenerator.generate(modules)

        // Should include C++ module header
        assertThat(generated).contains("// C++ TurboModule headers")
        assertThat(generated).contains("#include <CxxModule.h>")

        // Should have C++ module provider check
        assertThat(generated).contains("// Check C++ TurboModules (early-return pattern)")
        assertThat(generated).contains("if (moduleName == CxxModule::kModuleName) {")
        assertThat(generated).contains("return std::make_shared<CxxModule>(jsInvoker);")

        // Should not have Java module provider
        assertThat(generated).contains("// No autolinked Java TurboModules found")
    }

    @Test
    fun `generate with Fabric module includes component descriptor header and registration`() {
        val modules = listOf(
            NativeModule(
                name = "fabric-module",
                packageImportPath = null,
                packageInstance = null,
                dependencyConfiguration = null,
                buildTypes = emptyList(),
                libraryName = "FabricModule",
                componentDescriptors = listOf("MyComponentDescriptor", "AnotherComponentDescriptor"),
                cmakeListsPath = null,
                cxxModuleCMakeListsPath = null,
                cxxModuleCMakeListsModuleName = null,
                cxxModuleHeaderName = null,
                isPureCxxDependency = false
            )
        )

        val generated = CppAutolinkingGenerator.generate(modules)

        // Should include Fabric headers
        assertThat(generated).contains("// Fabric component descriptor headers")
        assertThat(generated).contains("<react/renderer/components/FabricModule/ComponentDescriptors.h>")
        assertThat(generated).contains("<react/renderer/components/FabricModule/MyComponentDescriptor.h>")

        // Should register codegen components + custom component descriptors
        assertThat(generated).contains("FabricModule_registerComponentDescriptorsFromCodegen(registry);")
        assertThat(generated).contains("registry->add(concreteComponentDescriptorProvider<MyComponentDescriptor>());")
        assertThat(generated).contains("registry->add(concreteComponentDescriptorProvider<AnotherComponentDescriptor>());")
    }

    @Test
    fun `generate with mixed modules includes TurboModule providers and Fabric registration`() {
        // Handle modules with both Java and C++ implementations
        val modules = listOf(
            createJavaModule("java-module", "JavaLib"),
            createCxxModule("cxx-module", "CxxLib", "CxxModule"),
            createFabricModule("fabric-module", "FabricLib", listOf("FabricComponent")),
            createMixedModule("mixed-module", "MixedLib", "MixedModule", listOf("MixedComponent"))
        )

        val generated = CppAutolinkingGenerator.generate(modules)

        // Should have C++ TurboModule headers
        assertThat(generated).contains("// C++ TurboModule headers")

        // Should have Fabric component headers or registration
        assertThat(generated).contains("// Fabric component descriptor headers")
        assertThat(generated).contains("registry->add(concreteComponentDescriptorProvider<FabricComponent>());")
        assertThat(generated).contains("registry->add(concreteComponentDescriptorProvider<MixedComponent>());")

        // Should have C++ provider checks
        assertThat(generated).contains("if (moduleName == CxxModule::kModuleName) {")
        assertThat(generated).contains("if (moduleName == MixedModule::kModuleName) {")

        // Should have Java provider calls
        assertThat(generated).contains("auto module_java_module = JavaLib_ModuleProvider(moduleName, params);")
        assertThat(generated).contains("auto module_mixed_module = MixedLib_ModuleProvider(moduleName, params);")
        assertThat(generated).contains("FabricLib_registerComponentDescriptorsFromCodegen(registry);")
        assertThat(generated).contains("MixedLib_registerComponentDescriptorsFromCodegen(registry);")
    }

    @Test
    fun `generate uses sanitized names for variables`() {
        // C++ identifier sanitization
        val modules = listOf(
            NativeModule(
                name = "module-with-hyphens",
                packageImportPath = "com.example.Package",
                packageInstance = "new Package()",
                dependencyConfiguration = null,
                buildTypes = emptyList(),
                libraryName = "ModuleLib",
                componentDescriptors = emptyList(),
                cmakeListsPath = null,
                cxxModuleCMakeListsPath = null,
                cxxModuleCMakeListsModuleName = null,
                cxxModuleHeaderName = null,
                isPureCxxDependency = false
            )
        )

        val generated = CppAutolinkingGenerator.generate(modules)

        // Should use sanitized name (hyphens -> underscores)
        assertThat(generated).contains("auto module_module_with_hyphens = ModuleLib_ModuleProvider(moduleName, params);")
        assertThat(generated).contains("if (module_module_with_hyphens != nullptr) {")
    }

    @Test
    fun `generate follows early-return pattern for multiple Java modules`() {
        // Early-return pattern
        val modules = listOf(
            createJavaModule("module1", "Lib1"),
            createJavaModule("module2", "Lib2"),
            createJavaModule("module3", "Lib3")
        )

        val generated = CppAutolinkingGenerator.generate(modules)

        // Should check each module and return early if found
        assertThat(generated).contains("auto module_module1 = Lib1_ModuleProvider(moduleName, params);")
        assertThat(generated).contains("if (module_module1 != nullptr) {")
        assertThat(generated).contains("return module_module1;")

        assertThat(generated).contains("auto module_module2 = Lib2_ModuleProvider(moduleName, params);")
        assertThat(generated).contains("if (module_module2 != nullptr) {")
        assertThat(generated).contains("return module_module2;")

        assertThat(generated).contains("auto module_module3 = Lib3_ModuleProvider(moduleName, params);")

        // Should return nullptr at the end
        val lines = generated.lines()
        val returnNullptrIndex = lines.indexOfLast { it.contains("return nullptr;") }
        assertThat(returnNullptrIndex).isGreaterThan(-1)
    }

    @Test
    fun `generate follows early-return pattern for multiple C++ modules`() {
        // Early-return pattern
        val modules = listOf(
            createCxxModule("module1", "Lib1", "Module1"),
            createCxxModule("module2", "Lib2", "Module2")
        )

        val generated = CppAutolinkingGenerator.generate(modules)

        // Should check each module and return early if found
        assertThat(generated).contains("if (moduleName == Module1::kModuleName) {")
        assertThat(generated).contains("return std::make_shared<Module1>(jsInvoker);")

        assertThat(generated).contains("if (moduleName == Module2::kModuleName) {")
        assertThat(generated).contains("return std::make_shared<Module2>(jsInvoker);")

        // Should return nullptr at the end
        assertThat(generated).contains("return nullptr;")
    }

    @Test
    fun `generate includes generation timestamp`() {
        val modules = emptyList<NativeModule>()

        val generated = CppAutolinkingGenerator.generate(modules)

        assertThat(generated).containsPattern("// Generation timestamp: \\d{4}-\\d{2}-\\d{2}T")
    }

    @Test
    fun `generate closes namespace correctly`() {
        val modules = emptyList<NativeModule>()

        val generated = CppAutolinkingGenerator.generate(modules)

        assertThat(generated).contains("} // namespace facebook::react")
    }

    @Test
    fun `generate includes modules with includesGeneratedCode flag`() {
        // includesGeneratedCode indicates the library ships generated files; it should still be autolinked.
        val modules = listOf(NativeModuleFixtures.createModuleWithCustomCodegen())

        val generated = CppAutolinkingGenerator.generate(modules)

        // Should call *_ModuleProvider for the module
        assertThat(generated).contains("CustomCodegenSpec_ModuleProvider")
    }

    @Test
    fun `generate includes standard modules and includesGeneratedCode modules`() {
        // Mixed list: one standard module, one that ships generated code
        val modules = NativeModuleFixtures.createMixedModules()

        val generated = CppAutolinkingGenerator.generate(modules)

        // Standard module should be included
        assertThat(generated).contains("ExampleSpec_ModuleProvider")

        // includesGeneratedCode module should also be included
        assertThat(generated).contains("CustomCodegenSpec_ModuleProvider")
    }

    // Helper methods for creating test modules
    private fun createJavaModule(name: String, libraryName: String): NativeModule {
        return NativeModule(
            name = name,
            packageImportPath = "com.example.$name.Package",
            packageInstance = "new Package()",
            dependencyConfiguration = null,
            buildTypes = emptyList(),
            libraryName = libraryName,
            componentDescriptors = emptyList(),
            cmakeListsPath = null,
            cxxModuleCMakeListsPath = null,
            cxxModuleCMakeListsModuleName = null,
            cxxModuleHeaderName = null,
            isPureCxxDependency = false
        )
    }

    private fun createCxxModule(name: String, libraryName: String, headerName: String): NativeModule {
        return NativeModule(
            name = name,
            packageImportPath = null,
            packageInstance = null,
            dependencyConfiguration = null,
            buildTypes = emptyList(),
            libraryName = libraryName,
            componentDescriptors = emptyList(),
            cmakeListsPath = null,
            cxxModuleCMakeListsPath = null,
            cxxModuleCMakeListsModuleName = null,
            cxxModuleHeaderName = headerName,
            isPureCxxDependency = true
        )
    }

    private fun createFabricModule(name: String, libraryName: String, descriptors: List<String>): NativeModule {
        return NativeModule(
            name = name,
            packageImportPath = null,
            packageInstance = null,
            dependencyConfiguration = null,
            buildTypes = emptyList(),
            libraryName = libraryName,
            componentDescriptors = descriptors,
            cmakeListsPath = null,
            cxxModuleCMakeListsPath = null,
            cxxModuleCMakeListsModuleName = null,
            cxxModuleHeaderName = null,
            isPureCxxDependency = false
        )
    }

    private fun createMixedModule(name: String, libraryName: String, headerName: String, descriptors: List<String>): NativeModule {
        return NativeModule(
            name = name,
            packageImportPath = "com.example.$name.Package",
            packageInstance = "new Package()",
            dependencyConfiguration = null,
            buildTypes = emptyList(),
            libraryName = libraryName,
            componentDescriptors = descriptors,
            cmakeListsPath = null,
            cxxModuleCMakeListsPath = null,
            cxxModuleCMakeListsModuleName = null,
            cxxModuleHeaderName = headerName,
            isPureCxxDependency = false
        )
    }
}
