/**
 * Cookies module implementation for iOS
 * Implements the CookiesSpec protocol generated by brick-codegen
 *
 * Supports both NSHTTPCookieStorage (for native HTTP requests)
 * and WKHTTPCookieStore (for WKWebView)
 *
 * Swift 6 compatible with strict concurrency checking
 */

import Foundation
import WebKit
import BrickModule

public final class CookiesModule: BrickModuleBase, CookiesSpec, @unchecked Sendable {
    public init() {
        super.init(moduleName: "Cookies")
    }

    // MARK: - Set Cookie

    public func set(url: String, cookie: CookiesCookie, useWebKit: Bool) async throws -> Bool {
        guard let urlObj = URL(string: url) else {
            throw BrickModuleError.executionError("Invalid URL: \(url)")
        }

        guard let httpCookie = makeHTTPCookie(from: cookie, url: urlObj) else {
            throw BrickModuleError.executionError("Failed to create cookie from provided data")
        }

        if useWebKit {
            return await setWebKitCookie(httpCookie)
        } else {
            HTTPCookieStorage.shared.setCookie(httpCookie)
            return true
        }
    }

    @MainActor
    private func setWebKitCookie(_ cookie: HTTPCookie) async -> Bool {
        let cookieStore = WKWebsiteDataStore.default().httpCookieStore
        await cookieStore.setCookie(cookie)
        return true
    }

    // MARK: - Get Cookies

    public func get(url: String, useWebKit: Bool) async throws -> [String: Any] {
        guard let urlObj = URL(string: url) else {
            throw BrickModuleError.executionError("Invalid URL: \(url)")
        }

        if useWebKit {
            let allCookies = await getWebKitCookies()
            let filteredCookies = allCookies.filter { cookie in
                Self.cookieMatchesURL(cookie: cookie, url: urlObj)
            }
            return Self.cookiesToDictionary(filteredCookies)
        } else {
            let cookies = HTTPCookieStorage.shared.cookies(for: urlObj) ?? []
            return Self.cookiesToDictionary(cookies)
        }
    }

    @MainActor
    private func getWebKitCookies() async -> [HTTPCookie] {
        let cookieStore = WKWebsiteDataStore.default().httpCookieStore
        return await cookieStore.allCookies()
    }

    // MARK: - Get All Cookies

    public func getAll(useWebKit: Bool) async throws -> [String: Any] {
        if useWebKit {
            let allCookies = await getWebKitCookies()
            return Self.cookiesToDictionary(allCookies)
        } else {
            let cookies = HTTPCookieStorage.shared.cookies ?? []
            return Self.cookiesToDictionary(cookies)
        }
    }

    // MARK: - Clear All Cookies

    public func clearAll(useWebKit: Bool) async throws -> Bool {
        if useWebKit {
            return await clearAllWebKitCookies()
        } else {
            let storage = HTTPCookieStorage.shared
            if let cookies = storage.cookies {
                for cookie in cookies {
                    storage.deleteCookie(cookie)
                }
            }
            return true
        }
    }

    @MainActor
    private func clearAllWebKitCookies() async -> Bool {
        let dataStore = WKWebsiteDataStore.default()
        let types: Set<String> = [WKWebsiteDataTypeCookies]
        let records = await dataStore.dataRecords(ofTypes: types)
        await dataStore.removeData(ofTypes: types, for: records)
        return true
    }

    // MARK: - Clear By Name

    public func clearByName(url: String, name: String, useWebKit: Bool) async throws -> Bool {
        guard let urlObj = URL(string: url) else {
            throw BrickModuleError.executionError("Invalid URL: \(url)")
        }

        if useWebKit {
            return await clearWebKitCookieByName(name: name, url: urlObj)
        } else {
            let storage = HTTPCookieStorage.shared
            let cookies = storage.cookies(for: urlObj) ?? []
            var deleted = false

            for cookie in cookies {
                if cookie.name == name {
                    storage.deleteCookie(cookie)
                    deleted = true
                }
            }

            return deleted
        }
    }

    @MainActor
    private func clearWebKitCookieByName(name: String, url: URL) async -> Bool {
        let cookieStore = WKWebsiteDataStore.default().httpCookieStore
        let allCookies = await cookieStore.allCookies()
        var deleted = false

        for cookie in allCookies {
            if cookie.name == name && Self.cookieMatchesURL(cookie: cookie, url: url) {
                await cookieStore.deleteCookie(cookie)
                deleted = true
            }
        }

        return deleted
    }

    // MARK: - Set From Response

    public func setFromResponse(url: String, cookie: String) async throws -> Bool {
        guard let urlObj = URL(string: url) else {
            throw BrickModuleError.executionError("Invalid URL: \(url)")
        }

        let headerFields = ["Set-Cookie": cookie]
        let cookies = HTTPCookie.cookies(withResponseHeaderFields: headerFields, for: urlObj)

        let storage = HTTPCookieStorage.shared
        for httpCookie in cookies {
            storage.setCookie(httpCookie)
        }

        return true
    }

    // MARK: - Get From Response

    public func getFromResponse(url: String) async throws -> [String: Any] {
        guard let urlObj = URL(string: url) else {
            throw BrickModuleError.executionError("Invalid URL: \(url)")
        }

        let cookies = HTTPCookieStorage.shared.cookies(for: urlObj) ?? []
        return Self.cookiesToDictionary(cookies)
    }

    // MARK: - Flush (No-op on iOS)

    public func flush() async throws -> Bool {
        // On iOS, cookies are automatically persisted
        return true
    }

    // MARK: - Remove Session Cookies

    public func removeSessionCookies() async throws -> Bool {
        let storage = HTTPCookieStorage.shared
        if let cookies = storage.cookies {
            for cookie in cookies where cookie.isSessionOnly {
                storage.deleteCookie(cookie)
            }
        }
        return true
    }

    // MARK: - Helper Methods

    private func makeHTTPCookie(from cookie: CookiesCookie, url: URL) -> HTTPCookie? {
        var properties: [HTTPCookiePropertyKey: Any] = [
            .name: cookie.name,
            .value: cookie.value,
            .path: cookie.path ?? "/",
        ]

        // Domain handling
        if let domain = cookie.domain {
            properties[.domain] = domain
        } else if let host = url.host {
            properties[.domain] = host
        } else {
            return nil
        }

        // Expiration handling
        if let expires = cookie.expires {
            if let expiresDate = Self.parseExpiresDate(expires) {
                properties[.expires] = expiresDate
            }
        }

        // Secure flag
        if let secure = cookie.secure, secure {
            properties[.secure] = "TRUE"
        }

        // Version
        if let version = cookie.version {
            properties[.version] = version
        }

        return HTTPCookie(properties: properties)
    }

    private static func parseExpiresDate(_ expires: String) -> Date? {
        // Try ISO 8601 format first
        let isoFormatter = ISO8601DateFormatter()
        if let date = isoFormatter.date(from: expires) {
            return date
        }

        // Try RFC 1123 format
        let rfc1123Formatter = DateFormatter()
        rfc1123Formatter.dateFormat = "EEE, dd MMM yyyy HH:mm:ss zzz"
        rfc1123Formatter.locale = Locale(identifier: "en_US_POSIX")
        if let date = rfc1123Formatter.date(from: expires) {
            return date
        }

        // Try as timestamp
        if let timestamp = Double(expires) {
            return Date(timeIntervalSince1970: timestamp / 1000)
        }

        return nil
    }

    private static func cookieMatchesURL(cookie: HTTPCookie, url: URL) -> Bool {
        guard let host = url.host else { return false }

        let domain = cookie.domain

        // Exact match
        if domain == host {
            return true
        }

        // Domain with leading dot matches subdomains
        if domain.hasPrefix(".") {
            let domainWithoutDot = String(domain.dropFirst())
            return host == domainWithoutDot || host.hasSuffix(domain)
        }

        // Check if host ends with domain
        return host.hasSuffix(".\(domain)")
    }

    private static func cookiesToDictionary(_ cookies: [HTTPCookie]) -> [String: Any] {
        var result: [String: [String: Any]] = [:]

        for cookie in cookies {
            var cookieDict: [String: Any] = [
                "name": cookie.name,
                "value": cookie.value,
                "path": cookie.path,
                "domain": cookie.domain,
                "version": String(cookie.version)
            ]

            if let expires = cookie.expiresDate?.iso8601String {
                cookieDict["expires"] = expires
            }
            cookieDict["secure"] = cookie.isSecure
            cookieDict["httpOnly"] = cookie.isHTTPOnly

            result[cookie.name] = cookieDict
        }

        return result
    }
}

// MARK: - Date Extension

private extension Date {
    var iso8601String: String {
        let formatter = ISO8601DateFormatter()
        return formatter.string(from: self)
    }
}
